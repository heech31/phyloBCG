hist(z)
z[ z < 1.5] <- 0
hist(z)
z<- rnorm(1000,0,1)#
hist(z)
hist(z[ z < -1.5])
hist(z[ z > -1.5])
z<- rnorm(1000,1,1)#
hist(z)
hist(z[ z > 0])
z[ z < 0] <- 0
z
hist(z)
z<- rnorm(1000,10,1)#
#
hist(z)
hist(z[ z > 9])
z[ z < 9] <- 0
hist(z)
z<- rnorm(1000,10,1)#
#
hist(z)
hist(z)
z<- rnorm(1000,10,1)#
#
hist(z)#
#
hist(z[ z > 9])#
z[ z < 9] <- 0
hist(z)
z<- rnorm(500,10,1)#
#
hist(z)#
#
hist(z[ z > 9])#
z[ z < 9] <- 0#
hist(z)
tmp<-matrix(rnorm(500^2,0,1),500,500)
svd.tmp <- svd(tmp)
R <- svd.tmp$u %*% t( svd.tmp$v )
R%*%t(R)
z[z==0]
z1 <- z[z!=0]
z1
z2
z2 <- z[z==0]
z2
length(z2)
length(z1)
n1 <- length(z1)
R[,1:n1]%*%z1
as.vector( R[,1:n1]%*%z1 )
x <- R[,(n1+1):500]
lm(y~-1+x)
y <- as.vector( R[,1:n1]%*%z1 )#
x <- R[,(n1+1):500]
lm(y~-1+x)
y
x
m <- lm(y~-1+x)
m
m$ceof
m$coef
hist( m$coef )
y
x
plot(y~x[,1])
plot(y~x[,2])
plot(y~x[,3])
tmp <- matrix( 1:500, 500,500 )
tmp
abs( tmp-tmp )
abs( tmp-t(tmp) )
Sigma <- 0.5^abs( tmp-t(tmp) )
z<- rnorm(500,10,1)#
tmp <- matrix( 1:500, 500,500 )
Sigma <- 0.5^abs( tmp-t(tmp) )
tmp <- svd( Sigma )
tmp$d
S <- tmp$u%*%diag( tmp$d^(1/2) )
S%*%t(S)
S%*%t(S) == S
image( S%*%t(S) )
image( Sigma )
hist(z)
hist(S%*%z)
diag( tmp-t(tmp) )
z<- rnorm(500,10,1)#
tmp <- matrix( 1:500, 500,500 )#
diag( tmp-t(tmp) )
image( tmp-t(tmp) )
image( abs(tmp-t(tmp)) )
hist(z)
hist(S%*%z)
z<- rnorm(500,0,1)#
tmp <- matrix( 1:500, 500,500 )#
image( abs(tmp-t(tmp)) )#
#
Sigma <- 0.5^abs( tmp-t(tmp) )#
tmp <- svd( Sigma )#
#
S <- tmp$u%*%diag( tmp$d^(1/2) )#
hist(z)#
hist(S%*%z)
hist(z)
hist(S%*%z)
z <- z + 10
hist(z[ z > 9])
z[ z < 9] <- 0
hist(z)
tmp<-matrix(rnorm(500^2,0,1),500,500)
svd.tmp <- svd(tmp)
R <- svd.tmp$u %*% t( svd.tmp$v )
z1 <- z[z!=0]
z2 <- z[z==0]
n1 <- length(z1)
y <- as.vector( R[,1:n1]%*%z1 )
x <- R[,(n1+1):500]
m <- lm(y~-1+x)
hist( m$coef )
plot(y~x[,3])
plot(y~x[,1])
x <- matrix( rnorm(30^2,0,1), 30, 30)
x <- matrix( rnorm(30^2,0,1), 30, 30)#
#
x11 <- x[1:10,1:10]#
x12 <- x[1:10,11:20]#
x13 <- x[1:10,21:30]#
#
x21 <- x[11:20,1:10]#
x22 <- x[11:20,11:20]#
x23 <- x[11:20,21:30]#
#
x31 <- x[21:30,1:10]#
x32 <- x[21:30,11:20]#
x33 <- x[21:30,21:30]
svd(x)
svd(x)$d
max( svd(x)$d )
svd(x11)$d
max( svd(x11)$d )
max( svd(x11)$d ) + max( svd(x12)$d ) + max( svd(x13)$d )
max( svd(x)$d )
max( svd(x11)$d ) + max( svd(x12)$d ) + max( svd(x13)$d )#
max( svd(x21)$d ) + max( svd(x22)$d ) + max( svd(x23)$d )#
max( svd(x31)$d ) + max( svd(x32)$d ) + max( svd(x33)$d )
set.seed(1)#
#
rnorm(3)
exp(0.1)
library(gridExtra)#
library(rgeos)#
library(maptools)#
library(ggplot2)#
require(dplyr)#
require(ggalt)#
require(scales)#
require(broom)#
library(nlme)#
library(maps)#
library(raster)#
us_states#
gg <- ggplot()#
gg <- gg + geom_polygon(data = ken.df,#
               aes(long, lat, group = group, fill = CCN_1),#
               color="#2b2b2b", size=0.15) #
us_states <- map_data("state")#
p <- ggplot(data = us_states,#
            mapping = aes(x = long, y = lat,#
                          group = group, fill = region))
p + geom_polygon(color = "gray90", size = 0.1) +#
    coord_map(projection = "albers", lat0 = 39, lat1 = 45) +#
    guides(fill = FALSE)#
#
p <- ggplot(data = us_states,#
            mapping = aes(x = long, y = lat,#
                          group = group, fill = region))#
#
p + geom_polygon(color = "gray90", size = 0.1) +#
    coord_map(projection = "albers", lat0 = 39, lat1 = 45) +#
    guides(fill = FALSE)
library(Rcpp)#
library(RcppArmadillo)
sourceCpp("ArmadilloExamples.cpp")
// [[Rcpp::export]]#
arma::mat matrix_mult(const arma::mat& X,#
const arma::mat& Y) {#
int m = X.n_rows;#
int n = Y.n_cols;#
arma::mat Z(m,n);#
Z = X * Y;#
return Z;#
}
library(RcppArmadill)
library(RcppArmadillo)
library(MGSDA)
MGSDA::solveMyLasso
MGSDA:::solveMyLasso
getAnywhere(MGSDA)
getAnywhere(solveMyLasso)
getAnywhere(.solveMyLasso)
getAnywhere(.solveMyLasso_c)
MGSDA:::.solveMyLasso_c
MGSDA:::solveMyLasso_c
getAnywhere(solveMyLasso_c)
library(MGSDA)
getAnywhere(solveMyLasso_c)
MGSDA:::solveMyLasso_c
MGSDA:::.solveMyLasso_c
getAnywhere(.solveMyLasso_c)
load("/Users/heecheolchung/Dropbox/Research/SAE/SAE_CBP/cbp_try.RData")
hist( cbp_try$beta[,1], 50, prob=TRUE )
hist( cbp_try$beta[,2], 50, prob=TRUE )
hist( cbp_try$beta[,3], 50, prob=TRUE )
hist( cbp_try$a, 50, prob=TRUE )
hist( cbp_try$sig2, 50, prob=TRUE )
pairs(CBP_try)
ls()
1989_cen
d1989_cen
d1989_cen[,"4pm"]
d1989_cen[,"4pm"]/1000
install.packages("spaMM")
spaMM:::.make_new_corr_lists(
spaMM:::.make_new_corr_lists
?plot_effect
??plot_effect
spaMM::plot_effect
??plot_effect
spaMM::plot_effects
pdep_effects
spaMM::pdep_effects
version()
Rversion()
session.info()
sessionInfo()
library(tidyverse)
install.packages("tidyverse")
library(tidyverse)#install.packages("tidyverse")
load("/Users/heecheolchung/Dropbox/Research/SAE/SAE_Spatial/simGAmissing/simGAmissingres/summGAmssing_all_.RData")
ls()
SD
load("/Users/heecheolchung/Dropbox/Research/SAE/SAE_Spatial/simGAmissing/simGAmissingres/summGAmissing_all_mem.RData")
ls()
SD
load("/Users/heecheolchung/Dropbox/Research/SAE/SAE_Spatial/simGAmissing/simGAmissingres/spSim_x1x2_17.RData")
ls()
scar
rm(list=ls())#
setwd("/Users/heecheolchung/Dropbox/Research/TAMU/graphical/QMPdata/")#
funcPath   <- "/Users/heecheolchung/Dropbox/Research/TAMU/graphical/functions/"#
resultPath <- "/Users/heecheolchung/Dropbox/Research/TAMU/graphical/QMPdata/results/"#
figPath    <- "/Users/heecheolchung/Dropbox/Research/TAMU/graphical/QMPdata/figures/"#
#
library(boot); library(tmvtnorm); library(coda)#
library(huge) #install.packages("huge")#
library(igraph) #install.packages("igraph")#
library(BDgraph) #install.packages("BDgraph")#
library(plyr);library(ggplot2);library(reshape);library(gridExtra)#
gg_color_hue <- function(n) {#
  hues = seq(15, 375, length = n + 1)#
  hcl(h = hues, l = 65, c = 100)[1:n]#
}#
cols <- gg_color_hue(20)#
#
library(corpcor) #install.packages("corpcor")#
#
## Load MCMC sample of size 30,000#
#load(paste(resultPath,"result.QMPtree30000.RData",sep="") )#
#load(paste(resultPath,"result.QMPtree_1e-3.RData",sep="") )#
load(paste(resultPath,"result.QMPtree_z_.RData",sep="") )#
#
###################################################################################
###################################################################################
###################################################################################
str(gibbsSample)#
QMP[,"Enterococcus"] # 943522.5   2186710.2         0.0   1246139.8   2947203.8
## Thin sample by 5, 30,000/nthin#
nthin   <- 5#
thinInd <-  nthin*(1:(nmc/nthin) )#
ngibbs  <- length( nthin*(1:(nmc/nthin)))#
## Chekc autocorrelation of spike variance v0#
## and tree scael sigma^2#
par(mfrow=c(2,3))#
hist( gibbsSample$v0_gibbs[thinInd],30)#
acf( gibbsSample$v0_gibbs[thinInd])#
plot( gibbsSample$v0_gibbs[thinInd],type="l",lwd=0.5)
## sigma^2 has high autocorrelation but #
## it is not a parameter of main interest#
hist( gibbsSample$sig2_gibbs,30)#
acf( gibbsSample$sig2_gibbs)#
plot( gibbsSample$sig2_gibbs,type="l",lwd=0.5)
hist( gibbsSample$sig2_gibbs[thinInd],30)
acf( gibbsSample$sig2_gibbs[thinInd])
plot( gibbsSample$sig2_gibbs[thinInd],type="l",lwd=0.5)
hist( gibbsSample$C_gibbs[4,5,thinInd],30)#
acf( gibbsSample$C_gibbs[4,5,thinInd])#
plot( gibbsSample$C_gibbs[4,5,thinInd],type="l",lwd=0.5)
hist( gibbsSample$C_gibbs[4,5,thinInd],30)#
acf( gibbsSample$C_gibbs[4,5,thinInd])#
plot( gibbsSample$C_gibbs[4,5,thinInd],type="l",lwd=0.5)
## Posterior histogram of sig2#
mean(gibbsSample$sig2_gibbs[thinInd],main="")#
df <- data.frame(s2gibbs=gibbsSample$sig2_gibbs[thinInd],v0gibbs=gibbsSample$v0_gibbs[thinInd])#
#
s2hist <- ggplot(df, aes(x=s2gibbs)) + #
    geom_histogram(aes(y=..density..), colour="black", fill="white") + #
    geom_density(alpha=.2, fill="#FF6666")
s2hist
ngibbs
## Posterior means of edge inclusion probabilities (pi_jk)#
pi_hat   <- Reduce("+", alply(gibbsSample$pi_gibbs[,,thinInd],3) )/ngibbs#
utriFlag <- upper.tri(pi_hat) # Flag for upper triangle part components#
ltriFlag <- lower.tri(pi_hat) # Flag for lower triangle part components#
pi_vec   <- pi_hat[utriFlag]#
#
## Roughly bimodal concentrated near 0 and 1.#
hist( pi_vec,50)
hist( gibbsSample$pi_gibbs[4,5,thinInd],30)
acf( gibbsSample$pi_gibbs[4,5,thinInd])
plot( gibbsSample$pi_gibbs[4,5,thinInd],type="l",lwd=0.5)
hist( gibbsSample$C_gibbs[4,5,thinInd],30)
par(mfrow=c(1,2))#
plot( gibbsSample$C_gibbs[1,2,thinInd],type="l",lwd=0.5)#
plot( gibbsSample$E_gibbs[1,2,thinInd],type="l",lwd=0.5)
par(mfrow=c(1,3))#
hist( gibbsSample$C_gibbs[1,2,thinInd],30)#
acf( gibbsSample$C_gibbs[1,2,thinInd])#
plot( gibbsSample$C_gibbs[1,2,thinInd],type="l",lwd=0.5)
par(mfrow=c(1,3))#
hist( gibbsSample$C_gibbs[1,2,thinInd],30)#
acf( gibbsSample$C_gibbs[1,2,thinInd])#
plot( gibbsSample$C_gibbs[1,2,thinInd],type="l",lwd=0.5)
par(mfrow=c(1,3))#
hist( gibbsSample$pi_gibbs[1,2,thinInd],30)#
acf( gibbsSample$pi_gibbs[1,2,thinInd])#
plot( gibbsSample$pi_gibbs[1,2,thinInd],type="l",lwd=0.5)
par(mfrow=c(2,3))#
hist( gibbsSample$C_gibbs[1,2,thinInd],30)#
acf( gibbsSample$C_gibbs[1,2,thinInd])#
plot( gibbsSample$C_gibbs[1,2,thinInd],type="l",lwd=0.5)#
hist( gibbsSample$pi_gibbs[1,2,thinInd],30)#
acf( gibbsSample$pi_gibbs[1,2,thinInd])#
plot( gibbsSample$pi_gibbs[1,2,thinInd],type="l",lwd=0.5)
mean(gibbsSample$pi_gibbs[1,2,thinInd])
## Roughly bimodal concentrated near 0 and 1.#
hist( pi_vec,50)#
## False discovery rate (Mitra et al., 2013; Peterson et al., 2015)#
fdr_th <- function(pi_vec,th){#
	num   <- sum( (1-pi_vec)*( pi_vec>th) )#
	denom <- sum( pi_vec>th ) + 1e-8#
	fdr <- num/denom#
	return(fdr)#
}#
ths <- seq(min(pi_vec),max(pi_vec),l=500)#
plot(ths, Vectorize(function(x) fdr_th(pi_vec,x)) (ths), type="l" )#
abline(v=0.95,col=2)
plot(ths, Vectorize(function(x) fdr_th(pi_vec,x)) (ths), type="l" )#
abline(v=0.95,col=2)
alpha_target <- 0.05 #Target FDR#
indexFDRlessthan0.05 <- which( Vectorize(function(x) fdr_th(pi_vec,x)) (ths) <= alpha_target)#
thresh <- min(ths[indexFDRlessthan0.05]) # The minimum graph threshold with FDR<= alpha_target#
thresh
## Check#
## Shoud be negative to control FDR below alpha_target#
fdr_th(pi_vec,thresh) - alpha_target#
## Estimate of adjacency matrix #
Wtmp  <- 1*( (Reduce("+" , alply(gibbsSample$pi_gibbs[,,thinInd],3) )/ngibbs )> thresh )#
mean(Wtmp[utriFlag])#
What <- Wtmp#
diag(What) <- 0#
colnames(What) <- colnames(x)#
rownames(What) <- colnames(x)  #
grph <- graph_from_adjacency_matrix(What, mode="undirected")#
# Try various graph layouts of the estimated network#
set.seed(77845)#
ceb <- cluster_edge_betweenness(grph) #
#plot(grph, vertex.label=colnames(What), layout = layout_with_lgl, vertex.size=rep(5,54) )#
#plot(ceb, grph, vertex.label=colnames(What), lwd=0.2 , layout = layout_nicely )#
#plot(ceb, grph, vertex.label=colnames(What), edge.width=0.5, asp=0.5, layout = layout_with_kk, vertex.size=rep(5,54) )#
#plot(ceb, grph, vertex.label=colnames(What), layout = layout_with_graphopt, vertex.size=rep(5,54) )#
## Draw graph with layout = layout_with_kk#
V(grph)$label.cex <- 1.1#
V(grph)$label.color <- "black"#
#
#Change the label location so that all fit in #
which(colnames(What)=="Methanosphaera")#
V(grph)$label.dist <- rep(1,54)#
#V(grph)$label.dist[54] <- -1#
V(grph)$edge.color <- "grey"#
#
layout_kk <- layout_with_kk(grph)#
#save(layout_kk,file="graphLayout.RData")#
#pdf(paste(figPath,"network.tree_1e-3.pdf",sep=""),width=12.5,height=5)#
par(oma=c(1,1,1,1),mar=c(0,0,1,1))#
plot(grph, vertex.label=colnames(What), vetex.label.color="black", vertex.color = membership(ceb)+2, #
     asp=0.4, edge.width=0.3, layout = layout_kk , vertex.size=rep(3,54), main="PhyloBCG" ) #
#dev.off()
ceb
str(ceb)
length(ceb)
ceb
.Random.seed[1]
set.seed(77845)
set.seed(77845)#
ceb <- cluster_edge_betweenness(grph) #
#plot(grph, vertex.label=colnames(What), layout = layout_with_lgl, vertex.size=rep(5,54) )#
#plot(ceb, grph, vertex.label=colnames(What), lwd=0.2 , layout = layout_nicely )#
#plot(ceb, grph, vertex.label=colnames(What), edge.width=0.5, asp=0.5, layout = layout_with_kk, vertex.size=rep(5,54) )#
#plot(ceb, grph, vertex.label=colnames(What), layout = layout_with_graphopt, vertex.size=rep(5,54) )#
## Draw graph with layout = layout_with_kk#
V(grph)$label.cex <- 1.1#
V(grph)$label.color <- "black"#
#
#Change the label location so that all fit in #
which(colnames(What)=="Methanosphaera")#
V(grph)$label.dist <- rep(1,54)#
#V(grph)$label.dist[54] <- -1#
V(grph)$edge.color <- "grey"#
#
layout_kk <- layout_with_kk(grph)#
#save(layout_kk,file="graphLayout.RData")#
#pdf(paste(figPath,"network.tree_1e-3.pdf",sep=""),width=12.5,height=5)#
par(oma=c(1,1,1,1),mar=c(0,0,1,1))#
plot(grph, vertex.label=colnames(What), vetex.label.color="black", vertex.color = membership(ceb)+2, #
     asp=0.4, edge.width=0.3, layout = layout_kk , vertex.size=rep(3,54), main="PhyloBCG" ) #
#dev.off()
ceb
ceb$groups
attr(ceb)
ceb[[1]]
ceb[[2]]
ceb[[3]]
ceb[[4]]
ceb[[5]]
ceb[[6]]
ceb[[7]]
ceb[[8]]
ceb[[9]]
ceb[[10]]
ceb[[11]]
ceb[[12]]
ceb[[13]]
ceb[[14]]
cols <- rep(1,length(qmptree$tip.label))#
  cols[ match( ceb[[2]] , qmptree$tip.label ) ] <- "cyan"#
  cols[ match( ceb[[4]] , qmptree$tip.label ) ] <- "black"#
  cols[ match( ceb[[6]] , qmptree$tip.label ) ] <- "red"#
  cols[ match( ceb[[7]] , qmptree$tip.label ) ] <- "margenta"
h <- plot(labeled.qmptree, type="phylogram",tip.col=cols)#
  ape::nodelabels(qmptree$node.label, cex=0.8, adj=1)
labeled.qmptree <- qmptree
h <- plot(labeled.qmptree, type="phylogram",tip.col=cols)#
  ape::nodelabels(qmptree$node.label, cex=0.8, adj=1)
labeled.qmptree$tip.label
ape::nodelabels(labeled.qmptree$node.label, cex=0.8, adj=1)
qmptree$node.label
ape::nodelabels(labeled.qmptree$node.label, cex=0.8, adj=1)
h <- plot(labeled.qmptree, type="phylogram",tip.col=cols)
cols[ match( ceb[[2]] , qmptree$tip.label ) ] <- "cyan"#
  cols[ match( ceb[[4]] , qmptree$tip.label ) ] <- "black"#
  cols[ match( ceb[[6]] , qmptree$tip.label ) ] <- "red"#
  cols[ match( ceb[[7]] , qmptree$tip.label ) ] <- "magenta"
h <- plot(labeled.qmptree, type="phylogram",tip.col=cols)
x
colMeans(x==0)
plot(colMeans(x==0))
h <- plot(labeled.qmptree, type="phylogram",tip.col=cols)#
  ape::nodelabels(labeled.qmptree$node.label, cex=0.8, adj=1)
par(mar=c(1,1,1,1),xpd=TRUE)#
  h <- plot(labeled.qmptree, type="phylogram",tip.col=cols)#
  ape::nodelabels(labeled.qmptree$node.label, cex=0.8, adj=1)
par(mar=c(1,1,1,1),xpd=TRUE)#
  h <- plot(labeled.qmptree, type="phylogram",tip.col=cols)#
  ape::nodelabels(labeled.qmptree$node.label, cex=0.8, adj=1)
lapply(ceb, length)
unlist(lapply(ceb, length))
sum(unlist(lapply(ceb, length)))
ceb
ceb$1
ceb$'1'
str(ceb)
Reduce("+" , alply(gibbsSample$pi_gibbs[,,thinInd],3)
Reduce("+" , alply(gibbsSample$pi_gibbs[,,thinInd],3) )
Reduce("+" , alply(gibbsSample$pi_gibbs[,,thinInd],3) )
ngibbs
(Reduce("+" , alply(gibbsSample$pi_gibbs[,,thinInd],3) )/ngibbs
)
thresh
Wtmp  <- 1*( (Reduce("+" , alply(gibbsSample$pi_gibbs[,,thinInd],3) )/ngibbs ) > thresh-0.1 )#
mean(Wtmp[utriFlag])#
What <- Wtmp#
diag(What) <- 0#
colnames(What) <- colnames(x)#
rownames(What) <- colnames(x)  #
grph <- graph_from_adjacency_matrix(What, mode="undirected")#
# Try various graph layouts of the estimated network#
set.seed(77845)#
ceb <- cluster_edge_betweenness(grph) #
#plot(grph, vertex.label=colnames(What), layout = layout_with_lgl, vertex.size=rep(5,54) )#
#plot(ceb, grph, vertex.label=colnames(What), lwd=0.2 , layout = layout_nicely )#
#plot(ceb, grph, vertex.label=colnames(What), edge.width=0.5, asp=0.5, layout = layout_with_kk, vertex.size=rep(5,54) )#
#plot(ceb, grph, vertex.label=colnames(What), layout = layout_with_graphopt, vertex.size=rep(5,54) )#
## Draw graph with layout = layout_with_kk#
V(grph)$label.cex <- 1.1#
V(grph)$label.color <- "black"#
#
#Change the label location so that all fit in #
which(colnames(What)=="Methanosphaera")#
V(grph)$label.dist <- rep(1,54)#
#V(grph)$label.dist[54] <- -1#
V(grph)$edge.color <- "grey"#
#
layout_kk <- layout_with_kk(grph)#
#save(layout_kk,file="graphLayout.RData")#
#pdf(paste(figPath,"network.tree_1e-3.pdf",sep=""),width=12.5,height=5)#
par(oma=c(1,1,1,1),mar=c(0,0,1,1))#
plot(grph, vertex.label=colnames(What), vetex.label.color="black", vertex.color = membership(ceb)+2, #
     asp=0.4, edge.width=0.3, layout = layout_kk , vertex.size=rep(3,54), main="PhyloBCG" ) #
#dev.off()
Wtmp  <- 1*( (Reduce("+" , alply(gibbsSample$pi_gibbs[,,thinInd],3) )/ngibbs ) > 0.756 )#
mean(Wtmp[utriFlag])#
What <- Wtmp#
diag(What) <- 0#
colnames(What) <- colnames(x)#
rownames(What) <- colnames(x)  #
grph <- graph_from_adjacency_matrix(What, mode="undirected")#
# Try various graph layouts of the estimated network#
set.seed(77845)#
ceb <- cluster_edge_betweenness(grph) #
#plot(grph, vertex.label=colnames(What), layout = layout_with_lgl, vertex.size=rep(5,54) )#
#plot(ceb, grph, vertex.label=colnames(What), lwd=0.2 , layout = layout_nicely )#
#plot(ceb, grph, vertex.label=colnames(What), edge.width=0.5, asp=0.5, layout = layout_with_kk, vertex.size=rep(5,54) )#
#plot(ceb, grph, vertex.label=colnames(What), layout = layout_with_graphopt, vertex.size=rep(5,54) )#
## Draw graph with layout = layout_with_kk#
V(grph)$label.cex <- 1.1#
V(grph)$label.color <- "black"#
#
#Change the label location so that all fit in #
which(colnames(What)=="Methanosphaera")#
V(grph)$label.dist <- rep(1,54)#
#V(grph)$label.dist[54] <- -1#
V(grph)$edge.color <- "grey"#
#
layout_kk <- layout_with_kk(grph)#
#save(layout_kk,file="graphLayout.RData")#
#pdf(paste(figPath,"network.tree_1e-3.pdf",sep=""),width=12.5,height=5)#
par(oma=c(1,1,1,1),mar=c(0,0,1,1))#
plot(grph, vertex.label=colnames(What), vetex.label.color="black", vertex.color = membership(ceb)+2, #
     asp=0.4, edge.width=0.3, layout = layout_kk , vertex.size=rep(3,54), main="PhyloBCG" ) #
#dev.off()
fdr_th <- function(pi_vec,th){#
	num   <- sum( (1-pi_vec)*( pi_vec>th) )#
	denom <- sum( pi_vec>th ) + 1e-8#
	fdr <- num/denom#
	return(fdr)#
}#
ths <- seq(min(pi_vec),max(pi_vec),l=500)#
plot(ths, Vectorize(function(x) fdr_th(pi_vec,x)) (ths), type="l" )#
abline(v=0.95,col=2)#
#
## thresh#
# alpha_target <- 0.1 #Target FDR#
# indexFDRlessthan0.1 <- which( Vectorize(function(x) fdr_th(pi_vec,x)) (ths)<=alpha_target)#
# thresh <- min(ths[indexFDRlessthan0.1]) # The minimum graph threshold with FDR<= alpha_target#
#
alpha_target <- 0.05 #Target FDR#
indexFDRlessthan0.05 <- which( Vectorize(function(x) fdr_th(pi_vec,x)) (ths) <= alpha_target)#
thresh <- min(ths[indexFDRlessthan0.05]) # The minimum graph threshold with FDR<= alpha_target#
thresh
## Check#
## Shoud be negative to control FDR below alpha_target#
fdr_th(pi_vec,thresh) - alpha_target
## Estimate of adjacency matrix #
Wtmp  <- 1*( (Reduce("+" , alply(gibbsSample$pi_gibbs[,,thinInd],3) )/ngibbs )> thresh )#
mean(Wtmp[utriFlag])#
What <- Wtmp#
diag(What) <- 0#
colnames(What) <- colnames(x)#
rownames(What) <- colnames(x)  #
grph <- graph_from_adjacency_matrix(What, mode="undirected")#
# Try various graph layouts of the estimated network#
set.seed(77845)#
ceb <- cluster_edge_betweenness(grph) #
#plot(grph, vertex.label=colnames(What), layout = layout_with_lgl, vertex.size=rep(5,54) )#
#plot(ceb, grph, vertex.label=colnames(What), lwd=0.2 , layout = layout_nicely )#
#plot(ceb, grph, vertex.label=colnames(What), edge.width=0.5, asp=0.5, layout = layout_with_kk, vertex.size=rep(5,54) )#
#plot(ceb, grph, vertex.label=colnames(What), layout = layout_with_graphopt, vertex.size=rep(5,54) )#
## Draw graph with layout = layout_with_kk#
V(grph)$label.cex <- 1.1#
V(grph)$label.color <- "black"#
#
#Change the label location so that all fit in #
which(colnames(What)=="Methanosphaera")#
V(grph)$label.dist <- rep(1,54)#
#V(grph)$label.dist[54] <- -1#
V(grph)$edge.color <- "grey"#
#
layout_kk <- layout_with_kk(grph)#
#save(layout_kk,file="graphLayout.RData")#
#pdf(paste(figPath,"network.tree_1e-3.pdf",sep=""),width=12.5,height=5)#
par(oma=c(1,1,1,1),mar=c(0,0,1,1))#
plot(grph, vertex.label=colnames(What), vetex.label.color="black", vertex.color = membership(ceb)+2, #
     asp=0.4, edge.width=0.3, layout = layout_kk , vertex.size=rep(3,54), main="PhyloBCG" ) #
#dev.off()
